// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: issues.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const closeIssue = `-- name: CloseIssue :exec
UPDATE issues SET
    status = 'closed',
    closed_at = ?,
    close_reason = ?,
    updated_at = ?
WHERE id = ?
`

type CloseIssueParams struct {
	ClosedAt    sql.NullTime   `json:"closed_at"`
	CloseReason sql.NullString `json:"close_reason"`
	UpdatedAt   time.Time      `json:"updated_at"`
	ID          string         `json:"id"`
}

func (q *Queries) CloseIssue(ctx context.Context, arg CloseIssueParams) error {
	_, err := q.db.ExecContext(ctx, closeIssue,
		arg.ClosedAt,
		arg.CloseReason,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const countIssuesByID = `-- name: CountIssuesByID :one
SELECT COUNT(*) as count FROM issues WHERE id = ?
`

func (q *Queries) CountIssuesByID(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIssuesByID, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIssuesByStatus = `-- name: CountIssuesByStatus :one
SELECT COUNT(*) as count FROM issues WHERE workspace_id = ? AND status = ?
`

type CountIssuesByStatusParams struct {
	WorkspaceID string `json:"workspace_id"`
	Status      string `json:"status"`
}

func (q *Queries) CountIssuesByStatus(ctx context.Context, arg CountIssuesByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIssuesByStatus, arg.WorkspaceID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIssuesByWorkspace = `-- name: CountIssuesByWorkspace :one
SELECT COUNT(*) as count FROM issues WHERE workspace_id = ?
`

func (q *Queries) CountIssuesByWorkspace(ctx context.Context, workspaceID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIssuesByWorkspace, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIssue = `-- name: CreateIssue :exec
INSERT INTO issues (
    id, workspace_id, title, description, acceptance_criteria, notes,
    status, priority, issue_type, assignee, external_ref,
    created_at, updated_at, closed_at, close_reason
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateIssueParams struct {
	ID                 string         `json:"id"`
	WorkspaceID        string         `json:"workspace_id"`
	Title              string         `json:"title"`
	Description        sql.NullString `json:"description"`
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
	Notes              sql.NullString `json:"notes"`
	Status             string         `json:"status"`
	Priority           int64          `json:"priority"`
	IssueType          string         `json:"issue_type"`
	Assignee           sql.NullString `json:"assignee"`
	ExternalRef        sql.NullString `json:"external_ref"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	ClosedAt           sql.NullTime   `json:"closed_at"`
	CloseReason        sql.NullString `json:"close_reason"`
}

func (q *Queries) CreateIssue(ctx context.Context, arg CreateIssueParams) error {
	_, err := q.db.ExecContext(ctx, createIssue,
		arg.ID,
		arg.WorkspaceID,
		arg.Title,
		arg.Description,
		arg.AcceptanceCriteria,
		arg.Notes,
		arg.Status,
		arg.Priority,
		arg.IssueType,
		arg.Assignee,
		arg.ExternalRef,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ClosedAt,
		arg.CloseReason,
	)
	return err
}

const deleteIssue = `-- name: DeleteIssue :exec
DELETE FROM issues WHERE id = ?
`

func (q *Queries) DeleteIssue(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteIssue, id)
	return err
}

const getIssue = `-- name: GetIssue :one
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues WHERE id = ?
`

func (q *Queries) GetIssue(ctx context.Context, id string) (*Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssue, id)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Title,
		&i.Description,
		&i.AcceptanceCriteria,
		&i.Notes,
		&i.Status,
		&i.Priority,
		&i.IssueType,
		&i.Assignee,
		&i.ExternalRef,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.CloseReason,
	)
	return &i, err
}

const getIssueByExternalRef = `-- name: GetIssueByExternalRef :one
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues WHERE external_ref = ?
`

func (q *Queries) GetIssueByExternalRef(ctx context.Context, externalRef sql.NullString) (*Issue, error) {
	row := q.db.QueryRowContext(ctx, getIssueByExternalRef, externalRef)
	var i Issue
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Title,
		&i.Description,
		&i.AcceptanceCriteria,
		&i.Notes,
		&i.Status,
		&i.Priority,
		&i.IssueType,
		&i.Assignee,
		&i.ExternalRef,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.CloseReason,
	)
	return &i, err
}

const getOpenNonBlockedIssues = `-- name: GetOpenNonBlockedIssues :many
SELECT i.id, i.workspace_id, i.title, i.description, i.acceptance_criteria, i.notes, i.status, i.priority, i.issue_type, i.assignee, i.external_ref, i.created_at, i.updated_at, i.closed_at, i.close_reason FROM issues i
LEFT JOIN dependencies d ON d.issue_id = i.id AND d.type IN ('blocks', 'parent-child')
LEFT JOIN issues blocker ON d.depends_on_id = blocker.id AND blocker.status != 'closed'
WHERE i.workspace_id = ?
  AND i.status IN ('open', 'in_progress')
GROUP BY i.id
HAVING COUNT(blocker.id) = 0
ORDER BY i.priority ASC, i.updated_at DESC
LIMIT ?
`

type GetOpenNonBlockedIssuesParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) GetOpenNonBlockedIssues(ctx context.Context, arg GetOpenNonBlockedIssuesParams) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, getOpenNonBlockedIssues, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByAssignee = `-- name: ListIssuesByAssignee :many
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues
WHERE workspace_id = ? AND assignee = ?
ORDER BY priority ASC, updated_at DESC
LIMIT ? OFFSET ?
`

type ListIssuesByAssigneeParams struct {
	WorkspaceID string         `json:"workspace_id"`
	Assignee    sql.NullString `json:"assignee"`
	Limit       int64          `json:"limit"`
	Offset      int64          `json:"offset"`
}

func (q *Queries) ListIssuesByAssignee(ctx context.Context, arg ListIssuesByAssigneeParams) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByAssignee,
		arg.WorkspaceID,
		arg.Assignee,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByStatus = `-- name: ListIssuesByStatus :many
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues
WHERE workspace_id = ? AND status = ?
ORDER BY priority ASC, updated_at DESC
LIMIT ? OFFSET ?
`

type ListIssuesByStatusParams struct {
	WorkspaceID string `json:"workspace_id"`
	Status      string `json:"status"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

func (q *Queries) ListIssuesByStatus(ctx context.Context, arg ListIssuesByStatusParams) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByStatus,
		arg.WorkspaceID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByType = `-- name: ListIssuesByType :many
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues
WHERE workspace_id = ? AND issue_type = ?
ORDER BY priority ASC, updated_at DESC
LIMIT ? OFFSET ?
`

type ListIssuesByTypeParams struct {
	WorkspaceID string `json:"workspace_id"`
	IssueType   string `json:"issue_type"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

func (q *Queries) ListIssuesByType(ctx context.Context, arg ListIssuesByTypeParams) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByType,
		arg.WorkspaceID,
		arg.IssueType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIssuesByWorkspace = `-- name: ListIssuesByWorkspace :many
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues
WHERE workspace_id = ?
ORDER BY priority ASC, updated_at DESC
LIMIT ? OFFSET ?
`

type ListIssuesByWorkspaceParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
	Offset      int64  `json:"offset"`
}

func (q *Queries) ListIssuesByWorkspace(ctx context.Context, arg ListIssuesByWorkspaceParams) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, listIssuesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reopenIssue = `-- name: ReopenIssue :exec
UPDATE issues SET
    status = 'open',
    closed_at = NULL,
    close_reason = NULL,
    updated_at = ?
WHERE id = ?
`

type ReopenIssueParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	ID        string    `json:"id"`
}

func (q *Queries) ReopenIssue(ctx context.Context, arg ReopenIssueParams) error {
	_, err := q.db.ExecContext(ctx, reopenIssue, arg.UpdatedAt, arg.ID)
	return err
}

const searchIssues = `-- name: SearchIssues :many
SELECT id, workspace_id, title, description, acceptance_criteria, notes, status, priority, issue_type, assignee, external_ref, created_at, updated_at, closed_at, close_reason FROM issues
WHERE workspace_id = ?
  AND (title LIKE ? OR description LIKE ?)
ORDER BY priority ASC, updated_at DESC
LIMIT ? OFFSET ?
`

type SearchIssuesParams struct {
	WorkspaceID string         `json:"workspace_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Limit       int64          `json:"limit"`
	Offset      int64          `json:"offset"`
}

func (q *Queries) SearchIssues(ctx context.Context, arg SearchIssuesParams) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, searchIssues,
		arg.WorkspaceID,
		arg.Title,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIssueAcceptanceCriteria = `-- name: UpdateIssueAcceptanceCriteria :exec
UPDATE issues SET acceptance_criteria = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueAcceptanceCriteriaParams struct {
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
	UpdatedAt          time.Time      `json:"updated_at"`
	ID                 string         `json:"id"`
}

func (q *Queries) UpdateIssueAcceptanceCriteria(ctx context.Context, arg UpdateIssueAcceptanceCriteriaParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueAcceptanceCriteria, arg.AcceptanceCriteria, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueAssignee = `-- name: UpdateIssueAssignee :exec
UPDATE issues SET assignee = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueAssigneeParams struct {
	Assignee  sql.NullString `json:"assignee"`
	UpdatedAt time.Time      `json:"updated_at"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdateIssueAssignee(ctx context.Context, arg UpdateIssueAssigneeParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueAssignee, arg.Assignee, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueDescription = `-- name: UpdateIssueDescription :exec
UPDATE issues SET description = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueDescriptionParams struct {
	Description sql.NullString `json:"description"`
	UpdatedAt   time.Time      `json:"updated_at"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateIssueDescription(ctx context.Context, arg UpdateIssueDescriptionParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueDescription, arg.Description, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueExternalRef = `-- name: UpdateIssueExternalRef :exec
UPDATE issues SET external_ref = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueExternalRefParams struct {
	ExternalRef sql.NullString `json:"external_ref"`
	UpdatedAt   time.Time      `json:"updated_at"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateIssueExternalRef(ctx context.Context, arg UpdateIssueExternalRefParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueExternalRef, arg.ExternalRef, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueNotes = `-- name: UpdateIssueNotes :exec
UPDATE issues SET notes = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueNotesParams struct {
	Notes     sql.NullString `json:"notes"`
	UpdatedAt time.Time      `json:"updated_at"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdateIssueNotes(ctx context.Context, arg UpdateIssueNotesParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueNotes, arg.Notes, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssuePriority = `-- name: UpdateIssuePriority :exec
UPDATE issues SET priority = ?, updated_at = ? WHERE id = ?
`

type UpdateIssuePriorityParams struct {
	Priority  int64     `json:"priority"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        string    `json:"id"`
}

func (q *Queries) UpdateIssuePriority(ctx context.Context, arg UpdateIssuePriorityParams) error {
	_, err := q.db.ExecContext(ctx, updateIssuePriority, arg.Priority, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueStatus = `-- name: UpdateIssueStatus :exec
UPDATE issues SET status = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueStatusParams struct {
	Status    string    `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        string    `json:"id"`
}

func (q *Queries) UpdateIssueStatus(ctx context.Context, arg UpdateIssueStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueStatus, arg.Status, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueTitle = `-- name: UpdateIssueTitle :exec
UPDATE issues SET title = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueTitleParams struct {
	Title     string    `json:"title"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        string    `json:"id"`
}

func (q *Queries) UpdateIssueTitle(ctx context.Context, arg UpdateIssueTitleParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueTitle, arg.Title, arg.UpdatedAt, arg.ID)
	return err
}

const updateIssueType = `-- name: UpdateIssueType :exec
UPDATE issues SET issue_type = ?, updated_at = ? WHERE id = ?
`

type UpdateIssueTypeParams struct {
	IssueType string    `json:"issue_type"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        string    `json:"id"`
}

func (q *Queries) UpdateIssueType(ctx context.Context, arg UpdateIssueTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateIssueType, arg.IssueType, arg.UpdatedAt, arg.ID)
	return err
}
