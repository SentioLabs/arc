// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dependencies.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addDependency = `-- name: AddDependency :exec
INSERT INTO dependencies (issue_id, depends_on_id, type, created_at, created_by)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(issue_id, depends_on_id) DO UPDATE SET
    type = excluded.type,
    created_at = excluded.created_at,
    created_by = excluded.created_by
`

type AddDependencyParams struct {
	IssueID     string         `json:"issue_id"`
	DependsOnID string         `json:"depends_on_id"`
	Type        string         `json:"type"`
	CreatedAt   time.Time      `json:"created_at"`
	CreatedBy   sql.NullString `json:"created_by"`
}

func (q *Queries) AddDependency(ctx context.Context, arg AddDependencyParams) error {
	_, err := q.db.ExecContext(ctx, addDependency,
		arg.IssueID,
		arg.DependsOnID,
		arg.Type,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	return err
}

const countBlockingIssues = `-- name: CountBlockingIssues :one
SELECT COUNT(*) as count FROM dependencies d
JOIN issues i ON d.depends_on_id = i.id
WHERE d.issue_id = ?
  AND d.type IN ('blocks', 'parent-child')
  AND i.status != 'closed'
`

func (q *Queries) CountBlockingIssues(ctx context.Context, issueID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBlockingIssues, issueID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDependencies = `-- name: CountDependencies :one
SELECT COUNT(*) as count FROM dependencies
WHERE issue_id = ? AND depends_on_id = ?
`

type CountDependenciesParams struct {
	IssueID     string `json:"issue_id"`
	DependsOnID string `json:"depends_on_id"`
}

func (q *Queries) CountDependencies(ctx context.Context, arg CountDependenciesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDependencies, arg.IssueID, arg.DependsOnID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDependenciesByIssue = `-- name: DeleteDependenciesByIssue :exec
DELETE FROM dependencies WHERE issue_id = ? OR depends_on_id = ?
`

type DeleteDependenciesByIssueParams struct {
	IssueID     string `json:"issue_id"`
	DependsOnID string `json:"depends_on_id"`
}

func (q *Queries) DeleteDependenciesByIssue(ctx context.Context, arg DeleteDependenciesByIssueParams) error {
	_, err := q.db.ExecContext(ctx, deleteDependenciesByIssue, arg.IssueID, arg.DependsOnID)
	return err
}

const getBlockedIssuesInWorkspace = `-- name: GetBlockedIssuesInWorkspace :many
SELECT i.id, i.workspace_id, i.title, i.description, i.acceptance_criteria,
       i.notes, i.status, i.priority, i.issue_type, i.assignee, i.external_ref,
       i.created_at, i.updated_at, i.closed_at, i.close_reason,
       COUNT(blocker.id) as blocked_by_count
FROM issues i
JOIN dependencies d ON d.issue_id = i.id AND d.type IN ('blocks', 'parent-child')
JOIN issues blocker ON d.depends_on_id = blocker.id AND blocker.status != 'closed'
WHERE i.workspace_id = ?
  AND i.status != 'closed'
GROUP BY i.id
ORDER BY i.priority ASC
LIMIT ?
`

type GetBlockedIssuesInWorkspaceParams struct {
	WorkspaceID string `json:"workspace_id"`
	Limit       int64  `json:"limit"`
}

type GetBlockedIssuesInWorkspaceRow struct {
	ID                 string         `json:"id"`
	WorkspaceID        string         `json:"workspace_id"`
	Title              string         `json:"title"`
	Description        sql.NullString `json:"description"`
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
	Notes              sql.NullString `json:"notes"`
	Status             string         `json:"status"`
	Priority           int64          `json:"priority"`
	IssueType          string         `json:"issue_type"`
	Assignee           sql.NullString `json:"assignee"`
	ExternalRef        sql.NullString `json:"external_ref"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	ClosedAt           sql.NullTime   `json:"closed_at"`
	CloseReason        sql.NullString `json:"close_reason"`
	BlockedByCount     int64          `json:"blocked_by_count"`
}

func (q *Queries) GetBlockedIssuesInWorkspace(ctx context.Context, arg GetBlockedIssuesInWorkspaceParams) ([]*GetBlockedIssuesInWorkspaceRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlockedIssuesInWorkspace, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBlockedIssuesInWorkspaceRow{}
	for rows.Next() {
		var i GetBlockedIssuesInWorkspaceRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
			&i.BlockedByCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockingIssues = `-- name: GetBlockingIssues :many
SELECT i.id, i.workspace_id, i.title, i.description, i.acceptance_criteria, i.notes, i.status, i.priority, i.issue_type, i.assignee, i.external_ref, i.created_at, i.updated_at, i.closed_at, i.close_reason FROM issues i
JOIN dependencies d ON i.id = d.depends_on_id
WHERE d.issue_id = ?
  AND d.type IN ('blocks', 'parent-child')
  AND i.status != 'closed'
ORDER BY i.priority ASC
`

func (q *Queries) GetBlockingIssues(ctx context.Context, issueID string) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, getBlockingIssues, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependencies = `-- name: GetDependencies :many
SELECT i.id, i.workspace_id, i.title, i.description, i.acceptance_criteria, i.notes, i.status, i.priority, i.issue_type, i.assignee, i.external_ref, i.created_at, i.updated_at, i.closed_at, i.close_reason FROM issues i
JOIN dependencies d ON i.id = d.depends_on_id
WHERE d.issue_id = ?
ORDER BY i.priority ASC
`

func (q *Queries) GetDependencies(ctx context.Context, issueID string) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, getDependencies, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependencyRecords = `-- name: GetDependencyRecords :many
SELECT issue_id, depends_on_id, type, created_at, created_by FROM dependencies WHERE issue_id = ?
`

func (q *Queries) GetDependencyRecords(ctx context.Context, issueID string) ([]*Dependency, error) {
	rows, err := q.db.QueryContext(ctx, getDependencyRecords, issueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Dependency{}
	for rows.Next() {
		var i Dependency
		if err := rows.Scan(
			&i.IssueID,
			&i.DependsOnID,
			&i.Type,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependentRecords = `-- name: GetDependentRecords :many
SELECT issue_id, depends_on_id, type, created_at, created_by FROM dependencies WHERE depends_on_id = ?
`

func (q *Queries) GetDependentRecords(ctx context.Context, dependsOnID string) ([]*Dependency, error) {
	rows, err := q.db.QueryContext(ctx, getDependentRecords, dependsOnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Dependency{}
	for rows.Next() {
		var i Dependency
		if err := rows.Scan(
			&i.IssueID,
			&i.DependsOnID,
			&i.Type,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependents = `-- name: GetDependents :many
SELECT i.id, i.workspace_id, i.title, i.description, i.acceptance_criteria, i.notes, i.status, i.priority, i.issue_type, i.assignee, i.external_ref, i.created_at, i.updated_at, i.closed_at, i.close_reason FROM issues i
JOIN dependencies d ON i.id = d.issue_id
WHERE d.depends_on_id = ?
ORDER BY i.priority ASC
`

func (q *Queries) GetDependents(ctx context.Context, dependsOnID string) ([]*Issue, error) {
	rows, err := q.db.QueryContext(ctx, getDependents, dependsOnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Title,
			&i.Description,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.ExternalRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.CloseReason,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeDependency = `-- name: RemoveDependency :exec
DELETE FROM dependencies WHERE issue_id = ? AND depends_on_id = ?
`

type RemoveDependencyParams struct {
	IssueID     string `json:"issue_id"`
	DependsOnID string `json:"depends_on_id"`
}

func (q *Queries) RemoveDependency(ctx context.Context, arg RemoveDependencyParams) error {
	_, err := q.db.ExecContext(ctx, removeDependency, arg.IssueID, arg.DependsOnID)
	return err
}
